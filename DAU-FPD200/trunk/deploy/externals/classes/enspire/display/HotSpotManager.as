import enspire.model.HotSpotData;import org.asapframework.util.debug.Log;import enspire.core.Server;import enspire.display.LayoutUtils;import enspire.model.Configs;import enspire.model.Labels;import enspire.utils.TextFieldUtils;import enspire.utils.GarbageCollection;class enspire.display.HotSpotManager {	private static var FLAG:String = "hotspots";	private var mcClip:MovieClip;	private var mcSegClip:MovieClip 	private var nWidth:Number;	private var nHeight:Number;	private var aSpots:Array;	private var nSelected:Number;	private var bGateHotSpots:Boolean;	private var bGated:Boolean	private var nFadeSpeed:Number;	function HotSpotManager(mcClip:MovieClip, nWidth:Number, nHeight:Number) {		this.mcClip = mcClip;		this.nWidth = nWidth;		this.nHeight = nHeight;		this.nFadeSpeed = isNaN(Configs.getConfig("nHotSpotFadeSpeed")) ? 1 : Configs.getConfig("nHotSpotFadeSpeed");		this.bGateHotSpots = Configs.getConfig("bGateHotSpots") == true ? true : false;		//Log.status("Created: clip is: "+mcClip, this.toString());	}	public function makeHotSpots(args:Object) {		this.bGated = false;		this.aSpots = getHotSpotsFromArgs(args);		this.nSelected = undefined;				this.mcSegClip = this.getClipFromStage("mcHotSpot0")._parent;				// if we do not have any HotSpots return		//Log.status("Checking for HotSpots - "+aSpots.length+" found", this.toString());		if(aSpots.length == 0) {			return;		}		for(var i = 0; i < this.aSpots.length; i++) {			var mc = mcSegClip["mcHotSpot"+i];			if(mc == false) {				//Log.warn("mcHotSpot"+i+" not found", this.toString());			}else{				//Log.debug("mcHotSpot"+i+" found", this.toString());				// create the HotSpot trigger				initHotSpot(mc, i);			}		}		// see if we are gatting these hot spots 		if(this.bGateHotSpots || (args["bGateHotSpots"] == "true")) {			Server.addFlag(FLAG);			Server.getController("gui").disableControl("next");			this.bGated = true;		}		// if we have a defualt open go ahead and open		if(isNaN(parseInt(args["nHotSpotStart"]))) {			var nId = parseInt(args["nHotSpotStart"])			mcSegClip["mcHotSpot"+nId].onRelease();		}	}	// this method is public so it can be called from in the mm	public function initHotSpot(mc:MovieClip, nIndex:Number) {		mc.manager = this;		mc.model = this.aSpots[nIndex];				// if there is a label add it to the triger clip		if(mc.model.sLabel != undefined) {			mc.mcText.tf.text = mc.model.sLabel;		}						var sEvent = mc.HotSpot.profile.sEvent		if(sEvent == "roll") {			mc.onOldRollOver = mc.onRollOver;			mc.onOldRollOut = mc.onRollOut;			mc.onRollOver = function() {				this.bVisited = true				this.manager.cuePopup(this.model.nIndex);				mc.onOldRollOver();			}			mc.onRollOut = function() {				this.manager.killPopup(this.model.nIndex);				mc.onOldRollOut();			}		}else{			mc.onOldRelease = mc.onRelease;			mc.onRelease = function() {				this.bVisited = true				this.manager.cuePopup(this.model.nIndex);				this.onOldRelease();			}		}	}	public function setSegClip(mc:MovieClip) {		this.mcSegClip = mc;	}	// close a popup	public function killPopup(nIndex:Number) {				// stop any screen animation that goes along with this hotspot		if(mcSegClip["mcAnim"+nIndex] != undefined) {			mcSegClip["mcAnim"+nIndex].gotoAndStop("off");		}		var mcPopup = this.mcClip["mcPopup" + nIndex]		if(this.aSpots[nIndex].profile["bFade"]) {			mcPopup.fadeOut(nFadeSpeed, undefined, 0, function() { mcPopup.removeMovieClip() });		}else{			mcPopup.removeMovieClip();		}		this.mcSegClip["mcHotSpot"+nIndex].enabled = true;	}	public function cuePopup(nIndex:Number) {		//Log.info("Launch popup: "+nIndex, this.toString());		var oData = this.aSpots[nIndex]		if(this.nSelected != undefined) {			this.killPopup(this.nSelected);		}		// attach popup movieclip		var mcTrigger = this.mcSegClip["mcHotSpot" + nIndex]		// get the poupskin from the profile		var sPopupSkin = oData.profile["sSkin"];		if(sPopupSkin == undefined) {			sPopupSkin = "InfoPopup";		}		// check to see if we have an animation to play		if(mcSegClip["mcAnim"+nIndex] != undefined) {			mcSegClip["mcAnim"+nIndex].gotoAndPlay("on");		}		// make popup		this.nSelected = nIndex;		var mcPopup = this.mcClip.attachMovie(sPopupSkin, "mcPopup" + nIndex, nIndex);		mcPopup.manager = this;		mcPopup.nIndex = nIndex;				mcPopup._alpha = 0;		// set text, header text, image , 		TextFieldUtils.setupTextArea(mcPopup.mcText.tf, oData.sText );		// if we have a header fill text and position		if(mcPopup.mcHeader != undefined) {			TextFieldUtils.setupTextArea(mcPopup.mcHeader.tf, oData.sHeader );			mcPopup.mcText._y = (mcPopup.mcHeader._y * 2) + mcPopup.mcHeader._height;			mcPopup.mcBg._height = (mcPopup.mcHeader._y * 3) + mcPopup.mcHeader._height + mcPopup.mcText._height;		}else{			mcPopup.mcBg._height = (mcPopup.mcText._y * 2) + mcPopup.mcText._height;		}				// if we have an image		if((mcPopup.mcImage != undefined) && (oData.sImage != undefined)) {			mcPopup.mcImage.gotoAndStop(oData.sImage);		}						// position popup		if(oData.profile.sMode == "follow") {			mcPopup.onEnterFrame = function() {				var nY = this._parent._ymouse;				var nX = this._parent._xmouse;				this._x = this.manager.getAdjustedX(nY, this._width);				this._y = this.manager.getAdjustedY(nY, this._height);			}		}else{			// if mm has out a mcPopupAll on Stage use that			if(mcSegClip["mcPopupAll"] != undefined) {								mcPopup._x = mcSegClip["mcPopupAll"]._x;				mcPopup._y = mcSegClip["mcPopupAll"]._y;							// if mm has place individual clip on stage for each poopup use that			}else if(mcSegClip["mcPopup"+nIndex] != undefined){								mcPopup._x = mcSegClip["mcPopup"+nIndex]._x;				mcPopup._y = mcSegClip["mcPopup"+nIndex]._y;							}else{				// get our aligment stuff				var sAlignX = (oData.sAlignX == undefined) ? oData.profile["sAlignX"] : oData.sAlignX;				var sAlignY = (oData.sAlignY == undefined) ? oData.profile["sAlignY"] : oData.sAlignY;												var nX:Number = mcTrigger._x;				var nY:Number = mcTrigger._y;								switch(sAlignX) {					case "center":						nX = (mcTrigger._x + (mcTrigger._width / 2)) - (mcPopup._width / 2);						break;					case "left":						nX = nX - mcPopup._width;						break;					case "right":						nX = mcTrigger._x + mcTrigger._width;						break;					case "centerStage":						nX = (this.nWidth / 2) - (mcPopup._width / 2)						break;				}								switch(sAlignY) {					case "center":						nY = (nY + (mcTrigger._height / 2)) - (mcPopup._height / 2);						break;					case "top":						nY = nY - mcPopup._height;						break; 					case "bottom":						nY = nY + mcTrigger._height;						break;					case "centerStage":						nY = (this.nHeight / 2) - (mcPopup._height / 2)						break;									}				// adjust for the content area width and height				mcPopup._x = getAdjustedX(nY, mcPopup._width);				mcPopup._y = getAdjustedY(nY, mcPopup._height);								//Log.debug("Popup X | Y : "+mcPopup._x+" | "+mcPopup._y, this.toString());			}		}		// set a close		mcPopup.mcClose.onPress = function() {			this.manager.killPopup(this.nIndex);		}		// if we have a textfield in our close button use a label		if((mcPopup.mcClose.mcText != undefined) && (oData.sLabel != undefined)) {			mcPopup.mcClose.mcText.tf.text = Labels.getLabel( oData.sLabel );		}		// make sure we remove any popups that are still up when we navigate		GarbageCollection.markAsTrash(mcPopup);				// set up follow if we are following the mouse		this.aSpots[nIndex].bVisited = true;		this.aSpots[nIndex].bSelected = true;		this.mcSegClip["mcHotSpot"+nIndex].enabled = false;						if(oData.profile["bFade"]) {			mcPopup.fadeIn(nFadeSpeed);		}else{			mcPopup._alpha = 100;		}		this.checkForComplete() 	}	public function getAdjustedY(nY:Number, nH:Number) {		if((nY + nH) > this.nHeight) {			nY  = this.nHeight - nH - 2;		}		if(nY < 0) {			nY  = 2;		}		return nY;	}	public function getAdjustedX(nX:Number, nW:Number) {		if((nX + nW) > this.nWidth) {			nX  = this.nWidth - nW - 2;		}		if(nX < 0) {			nX  = 2;		}		return nX;	}		// this function will clear the flag if we are gatted	private function checkForComplete() {		if(!bGated) {			return;		}		for(var i = 0; i < this.aSpots.length; i++) {			if(this.aSpots[i].bVisited == false) {				return;			}		}		this.bGated = false;		Server.getController("app").onEndElement(FLAG)	}	// this function builds the data objects for the HotSpots	private function getHotSpotsFromArgs(args:Object) {		var aHotSpotData:Array = new Array();		var nIndex:Number = 0;		var bAllFound:Boolean = false;		// set a default profile for our HotSpots to use		var sDefaultProfile = (args["sHotSpotProfile"] == undefined) ? "HotSpot" : args["sHotSpotProfile"];		var sDefaultLabel = args["sHotSpotClose"];		// get our hotspost from the arg list		while(!bAllFound) {			var sSpot = "sHotSpot"+nIndex;			if(args[sSpot] == undefined) {				bAllFound = true;				continue;			}			// create a HotSpot data object			var spot = new HotSpotData(args[sSpot], nIndex);						// add in any other defined things that might be needed			var sProfile = (args["sHotSpotProfile"+nIndex] == undefined) ? sDefaultProfile : args["sHotSpotProfile"+nIndex];						spot.profile = Configs.getProfile(sProfile);			spot.sHeader = args["sHotSpotHeader"+nIndex];			spot.sImage = args["sHotSpotImage"+nIndex];			spot.sLabel = args["sHotSpotLabel"+nIndex];			spot.sClose = (args["sHotSpotClose"+nIndex] == undefined) ?  sDefaultLabel : args["sHotSpotClose"+nIndex]			spot.sAlignX = args["sHotSpotXalign"+nIndex];			spot.sAlignY = args["sHotSpotYalign"+nIndex];						aHotSpotData.push(spot);			// //trace this out			//Log.info(spot.toString(), this.toString());						nIndex++;		}		return aHotSpotData;	}	// find a clip on the stage	private function getClipFromStage(sName:String) {		return LayoutUtils.find(Server.getController("clipPlayer").mcSkin.mcClip, sName, "movieclip");	}	function toString() {		return "enspire.display.HotSpotManager";	}}